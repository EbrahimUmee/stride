// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stride/auction/auction_pool.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AuctionState int32

const (
	AuctionState_COMPLETE AuctionState = 0
	AuctionState_RUNNING  AuctionState = 1
	AuctionState_REVEAL   AuctionState = 2
	AuctionState_PAYOUT   AuctionState = 3
)

var AuctionState_name = map[int32]string{
	0: "COMPLETE",
	1: "RUNNING",
	2: "REVEAL",
	3: "PAYOUT",
}

var AuctionState_value = map[string]int32{
	"COMPLETE": 0,
	"RUNNING":  1,
	"REVEAL":   2,
	"PAYOUT":   3,
}

func (x AuctionState) String() string {
	return proto.EnumName(AuctionState_name, int32(x))
}

func (AuctionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e7c158d68ebb3589, []int{0}
}

// English style auction specific parameters
// Starts low with increasing bids, auction ends if no new bids occur
// for endDuration blocks in a row and goes to current winner
// When a higher bid comes in, the lastBlock is set now + endDuration
type AscendingAuction struct {
	Status            AuctionState                `protobuf:"varint,1,opt,name=status,proto3,enum=stride.auction.AuctionState" json:"status,omitempty"`
	AuctionProperties *AscendingAuctionProperties `protobuf:"bytes,2,opt,name=auctionProperties,proto3" json:"auctionProperties,omitempty"`
	PoolProperties    *AuctionPoolProperties      `protobuf:"bytes,3,opt,name=poolProperties,proto3" json:"poolProperties,omitempty"`
	LastBlock         uint64                      `protobuf:"varint,4,opt,name=lastBlock,proto3" json:"lastBlock,omitempty"`
	Bids              []*OpenBid                  `protobuf:"bytes,5,rep,name=bids,proto3" json:"bids,omitempty"`
}

func (m *AscendingAuction) Reset()         { *m = AscendingAuction{} }
func (m *AscendingAuction) String() string { return proto.CompactTextString(m) }
func (*AscendingAuction) ProtoMessage()    {}
func (*AscendingAuction) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7c158d68ebb3589, []int{0}
}
func (m *AscendingAuction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AscendingAuction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AscendingAuction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AscendingAuction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AscendingAuction.Merge(m, src)
}
func (m *AscendingAuction) XXX_Size() int {
	return m.Size()
}
func (m *AscendingAuction) XXX_DiscardUnknown() {
	xxx_messageInfo_AscendingAuction.DiscardUnknown(m)
}

var xxx_messageInfo_AscendingAuction proto.InternalMessageInfo

func (m *AscendingAuction) GetStatus() AuctionState {
	if m != nil {
		return m.Status
	}
	return AuctionState_COMPLETE
}

func (m *AscendingAuction) GetAuctionProperties() *AscendingAuctionProperties {
	if m != nil {
		return m.AuctionProperties
	}
	return nil
}

func (m *AscendingAuction) GetPoolProperties() *AuctionPoolProperties {
	if m != nil {
		return m.PoolProperties
	}
	return nil
}

func (m *AscendingAuction) GetLastBlock() uint64 {
	if m != nil {
		return m.LastBlock
	}
	return 0
}

func (m *AscendingAuction) GetBids() []*OpenBid {
	if m != nil {
		return m.Bids
	}
	return nil
}

// Dutch style auction specific parameters
// Starts high at startingBid, moves bid down bidStepSize each
// bidStepDuration blocks until someone is willing to bid and win
type DescendingAuction struct {
	Status            AuctionState                 `protobuf:"varint,1,opt,name=status,proto3,enum=stride.auction.AuctionState" json:"status,omitempty"`
	AuctionProperties *DescendingAuctionProperties `protobuf:"bytes,2,opt,name=auctionProperties,proto3" json:"auctionProperties,omitempty"`
	PoolProperties    *AuctionPoolProperties       `protobuf:"bytes,3,opt,name=poolProperties,proto3" json:"poolProperties,omitempty"`
	CurrentSupply     uint64                       `protobuf:"varint,4,opt,name=currentSupply,proto3" json:"currentSupply,omitempty"`
	CurrentBid        uint64                       `protobuf:"varint,5,opt,name=currentBid,proto3" json:"currentBid,omitempty"`
	NextStep          uint64                       `protobuf:"varint,6,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
	Bids              []*OpenBid                   `protobuf:"bytes,7,rep,name=bids,proto3" json:"bids,omitempty"`
}

func (m *DescendingAuction) Reset()         { *m = DescendingAuction{} }
func (m *DescendingAuction) String() string { return proto.CompactTextString(m) }
func (*DescendingAuction) ProtoMessage()    {}
func (*DescendingAuction) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7c158d68ebb3589, []int{1}
}
func (m *DescendingAuction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DescendingAuction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DescendingAuction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DescendingAuction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescendingAuction.Merge(m, src)
}
func (m *DescendingAuction) XXX_Size() int {
	return m.Size()
}
func (m *DescendingAuction) XXX_DiscardUnknown() {
	xxx_messageInfo_DescendingAuction.DiscardUnknown(m)
}

var xxx_messageInfo_DescendingAuction proto.InternalMessageInfo

func (m *DescendingAuction) GetStatus() AuctionState {
	if m != nil {
		return m.Status
	}
	return AuctionState_COMPLETE
}

func (m *DescendingAuction) GetAuctionProperties() *DescendingAuctionProperties {
	if m != nil {
		return m.AuctionProperties
	}
	return nil
}

func (m *DescendingAuction) GetPoolProperties() *AuctionPoolProperties {
	if m != nil {
		return m.PoolProperties
	}
	return nil
}

func (m *DescendingAuction) GetCurrentSupply() uint64 {
	if m != nil {
		return m.CurrentSupply
	}
	return 0
}

func (m *DescendingAuction) GetCurrentBid() uint64 {
	if m != nil {
		return m.CurrentBid
	}
	return 0
}

func (m *DescendingAuction) GetNextStep() uint64 {
	if m != nil {
		return m.NextStep
	}
	return 0
}

func (m *DescendingAuction) GetBids() []*OpenBid {
	if m != nil {
		return m.Bids
	}
	return nil
}

// Sealed Bid style auction specific parameters
// Auction is open for sealed bids from firstBlock to lastBlock
// after last block but before revealBlock, bidders reveal unsealed bids
type SealedBidAuction struct {
	Status            AuctionState                `protobuf:"varint,1,opt,name=status,proto3,enum=stride.auction.AuctionState" json:"status,omitempty"`
	AuctionProperties *SealedBidAuctionProperties `protobuf:"bytes,2,opt,name=auctionProperties,proto3" json:"auctionProperties,omitempty"`
	PoolProperties    *AuctionPoolProperties      `protobuf:"bytes,3,opt,name=poolProperties,proto3" json:"poolProperties,omitempty"`
	FirstBlock        uint64                      `protobuf:"varint,4,opt,name=firstBlock,proto3" json:"firstBlock,omitempty"`
	LastBlock         uint64                      `protobuf:"varint,5,opt,name=lastBlock,proto3" json:"lastBlock,omitempty"`
	RevealBlock       uint64                      `protobuf:"varint,6,opt,name=revealBlock,proto3" json:"revealBlock,omitempty"`
	SealedBids        []*SealedBid                `protobuf:"bytes,7,rep,name=sealedBids,proto3" json:"sealedBids,omitempty"`
	RevealedBids      []*OpenBid                  `protobuf:"bytes,8,rep,name=revealedBids,proto3" json:"revealedBids,omitempty"`
}

func (m *SealedBidAuction) Reset()         { *m = SealedBidAuction{} }
func (m *SealedBidAuction) String() string { return proto.CompactTextString(m) }
func (*SealedBidAuction) ProtoMessage()    {}
func (*SealedBidAuction) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7c158d68ebb3589, []int{2}
}
func (m *SealedBidAuction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealedBidAuction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealedBidAuction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealedBidAuction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealedBidAuction.Merge(m, src)
}
func (m *SealedBidAuction) XXX_Size() int {
	return m.Size()
}
func (m *SealedBidAuction) XXX_DiscardUnknown() {
	xxx_messageInfo_SealedBidAuction.DiscardUnknown(m)
}

var xxx_messageInfo_SealedBidAuction proto.InternalMessageInfo

func (m *SealedBidAuction) GetStatus() AuctionState {
	if m != nil {
		return m.Status
	}
	return AuctionState_COMPLETE
}

func (m *SealedBidAuction) GetAuctionProperties() *SealedBidAuctionProperties {
	if m != nil {
		return m.AuctionProperties
	}
	return nil
}

func (m *SealedBidAuction) GetPoolProperties() *AuctionPoolProperties {
	if m != nil {
		return m.PoolProperties
	}
	return nil
}

func (m *SealedBidAuction) GetFirstBlock() uint64 {
	if m != nil {
		return m.FirstBlock
	}
	return 0
}

func (m *SealedBidAuction) GetLastBlock() uint64 {
	if m != nil {
		return m.LastBlock
	}
	return 0
}

func (m *SealedBidAuction) GetRevealBlock() uint64 {
	if m != nil {
		return m.RevealBlock
	}
	return 0
}

func (m *SealedBidAuction) GetSealedBids() []*SealedBid {
	if m != nil {
		return m.SealedBids
	}
	return nil
}

func (m *SealedBidAuction) GetRevealedBids() []*OpenBid {
	if m != nil {
		return m.RevealedBids
	}
	return nil
}

// Would be more elegant if protobuf had a nice way to do interfaces but
// the algorithm is used to determine which one of the optional fields is set
type Auction struct {
	Algorithm AuctionType `protobuf:"varint,1,opt,name=algorithm,proto3,enum=stride.auction.AuctionType" json:"algorithm,omitempty"`
	// Types that are valid to be assigned to XAscendingAuction:
	//	*Auction_AscendingAuction
	XAscendingAuction isAuction_XAscendingAuction `protobuf_oneof:"_ascendingAuction"`
	// Types that are valid to be assigned to XDescendingAuction:
	//	*Auction_DescendingAuction
	XDescendingAuction isAuction_XDescendingAuction `protobuf_oneof:"_descendingAuction"`
	// Types that are valid to be assigned to XSealedBidAuction:
	//	*Auction_SealedBidAuction
	XSealedBidAuction isAuction_XSealedBidAuction `protobuf_oneof:"_sealedBidAuction"`
}

func (m *Auction) Reset()         { *m = Auction{} }
func (m *Auction) String() string { return proto.CompactTextString(m) }
func (*Auction) ProtoMessage()    {}
func (*Auction) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7c158d68ebb3589, []int{3}
}
func (m *Auction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Auction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Auction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Auction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Auction.Merge(m, src)
}
func (m *Auction) XXX_Size() int {
	return m.Size()
}
func (m *Auction) XXX_DiscardUnknown() {
	xxx_messageInfo_Auction.DiscardUnknown(m)
}

var xxx_messageInfo_Auction proto.InternalMessageInfo

type isAuction_XAscendingAuction interface {
	isAuction_XAscendingAuction()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAuction_XDescendingAuction interface {
	isAuction_XDescendingAuction()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAuction_XSealedBidAuction interface {
	isAuction_XSealedBidAuction()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Auction_AscendingAuction struct {
	AscendingAuction *AscendingAuction `protobuf:"bytes,2,opt,name=ascendingAuction,proto3,oneof" json:"ascendingAuction,omitempty"`
}
type Auction_DescendingAuction struct {
	DescendingAuction *DescendingAuction `protobuf:"bytes,3,opt,name=descendingAuction,proto3,oneof" json:"descendingAuction,omitempty"`
}
type Auction_SealedBidAuction struct {
	SealedBidAuction *SealedBidAuction `protobuf:"bytes,4,opt,name=sealedBidAuction,proto3,oneof" json:"sealedBidAuction,omitempty"`
}

func (*Auction_AscendingAuction) isAuction_XAscendingAuction()   {}
func (*Auction_DescendingAuction) isAuction_XDescendingAuction() {}
func (*Auction_SealedBidAuction) isAuction_XSealedBidAuction()   {}

func (m *Auction) GetXAscendingAuction() isAuction_XAscendingAuction {
	if m != nil {
		return m.XAscendingAuction
	}
	return nil
}
func (m *Auction) GetXDescendingAuction() isAuction_XDescendingAuction {
	if m != nil {
		return m.XDescendingAuction
	}
	return nil
}
func (m *Auction) GetXSealedBidAuction() isAuction_XSealedBidAuction {
	if m != nil {
		return m.XSealedBidAuction
	}
	return nil
}

func (m *Auction) GetAlgorithm() AuctionType {
	if m != nil {
		return m.Algorithm
	}
	return AuctionType_UNKNOWN
}

func (m *Auction) GetAscendingAuction() *AscendingAuction {
	if x, ok := m.GetXAscendingAuction().(*Auction_AscendingAuction); ok {
		return x.AscendingAuction
	}
	return nil
}

func (m *Auction) GetDescendingAuction() *DescendingAuction {
	if x, ok := m.GetXDescendingAuction().(*Auction_DescendingAuction); ok {
		return x.DescendingAuction
	}
	return nil
}

func (m *Auction) GetSealedBidAuction() *SealedBidAuction {
	if x, ok := m.GetXSealedBidAuction().(*Auction_SealedBidAuction); ok {
		return x.SealedBidAuction
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Auction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Auction_AscendingAuction)(nil),
		(*Auction_DescendingAuction)(nil),
		(*Auction_SealedBidAuction)(nil),
	}
}

// Auction Pool has an address with some assets and restrictions on the types
// of auctions which can be run for this pool.
type AuctionPool struct {
	Id             uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	PoolProperties *AuctionPoolProperties `protobuf:"bytes,2,opt,name=poolProperties,proto3" json:"poolProperties,omitempty"`
	LatestAuction  *Auction               `protobuf:"bytes,8,opt,name=latestAuction,proto3" json:"latestAuction,omitempty"`
}

func (m *AuctionPool) Reset()         { *m = AuctionPool{} }
func (m *AuctionPool) String() string { return proto.CompactTextString(m) }
func (*AuctionPool) ProtoMessage()    {}
func (*AuctionPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7c158d68ebb3589, []int{4}
}
func (m *AuctionPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuctionPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuctionPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuctionPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuctionPool.Merge(m, src)
}
func (m *AuctionPool) XXX_Size() int {
	return m.Size()
}
func (m *AuctionPool) XXX_DiscardUnknown() {
	xxx_messageInfo_AuctionPool.DiscardUnknown(m)
}

var xxx_messageInfo_AuctionPool proto.InternalMessageInfo

func (m *AuctionPool) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AuctionPool) GetPoolProperties() *AuctionPoolProperties {
	if m != nil {
		return m.PoolProperties
	}
	return nil
}

func (m *AuctionPool) GetLatestAuction() *Auction {
	if m != nil {
		return m.LatestAuction
	}
	return nil
}

func init() {
	proto.RegisterEnum("stride.auction.AuctionState", AuctionState_name, AuctionState_value)
	proto.RegisterType((*AscendingAuction)(nil), "stride.auction.AscendingAuction")
	proto.RegisterType((*DescendingAuction)(nil), "stride.auction.DescendingAuction")
	proto.RegisterType((*SealedBidAuction)(nil), "stride.auction.SealedBidAuction")
	proto.RegisterType((*Auction)(nil), "stride.auction.Auction")
	proto.RegisterType((*AuctionPool)(nil), "stride.auction.AuctionPool")
}

func init() { proto.RegisterFile("stride/auction/auction_pool.proto", fileDescriptor_e7c158d68ebb3589) }

var fileDescriptor_e7c158d68ebb3589 = []byte{
	// 685 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xcd, 0x4e, 0xdb, 0x4a,
	0x14, 0xce, 0x38, 0x21, 0x84, 0x13, 0x88, 0x9c, 0xb9, 0x57, 0xc2, 0xfc, 0xc8, 0x37, 0x44, 0xf7,
	0x4a, 0x11, 0xe8, 0x26, 0x15, 0x6d, 0x17, 0xa8, 0xea, 0x22, 0x6e, 0xa3, 0xd2, 0x8a, 0x9f, 0x30,
	0x09, 0x55, 0xe9, 0x06, 0x39, 0xf1, 0x10, 0x46, 0x35, 0xb6, 0x65, 0x4f, 0x10, 0xd9, 0x55, 0x5d,
	0xb1, 0xec, 0x7b, 0xf4, 0x15, 0xfa, 0x00, 0xed, 0x8e, 0x65, 0x97, 0x15, 0xbc, 0x48, 0x85, 0x33,
	0x09, 0xf6, 0x98, 0x94, 0x4a, 0xad, 0x58, 0x25, 0x39, 0xe7, 0x3b, 0xdf, 0x39, 0x73, 0xbe, 0x6f,
	0x32, 0xb0, 0x12, 0x70, 0x9f, 0x59, 0xb4, 0x66, 0xf6, 0xbb, 0x9c, 0xb9, 0xce, 0xe8, 0xf3, 0xd0,
	0x73, 0x5d, 0xbb, 0xea, 0xf9, 0x2e, 0x77, 0x71, 0x61, 0x08, 0xa9, 0x8a, 0xd4, 0xe2, 0x42, 0xcf,
	0x75, 0x7b, 0x36, 0xad, 0x85, 0xd9, 0x4e, 0xff, 0xa8, 0x66, 0x3a, 0x83, 0x21, 0x74, 0x51, 0x93,
	0xd8, 0x3a, 0xcc, 0x12, 0x99, 0x25, 0x29, 0xe3, 0x99, 0xbe, 0x79, 0x12, 0x88, 0xe4, 0x3f, 0x72,
	0xd2, 0x77, 0x3d, 0xea, 0x73, 0x46, 0x05, 0xa0, 0xfc, 0x59, 0x01, 0xb5, 0x1e, 0x74, 0xa9, 0x63,
	0x31, 0xa7, 0x57, 0x1f, 0xa2, 0xf0, 0x23, 0xc8, 0x06, 0xdc, 0xe4, 0xfd, 0x40, 0x43, 0x25, 0x54,
	0x29, 0xac, 0x2f, 0x57, 0xe3, 0x83, 0x56, 0x05, 0xb0, 0xc5, 0x4d, 0x4e, 0x89, 0xc0, 0xe2, 0x37,
	0x50, 0x14, 0xf9, 0xe6, 0xb8, 0x8b, 0xa6, 0x94, 0x50, 0x25, 0xbf, 0xbe, 0x9a, 0x20, 0x90, 0x5a,
	0xde, 0x54, 0x90, 0x24, 0x09, 0xde, 0x86, 0xc2, 0xf5, 0xd6, 0x22, 0xb4, 0xe9, 0x90, 0xf6, 0xbf,
	0x09, 0x73, 0x35, 0x63, 0x60, 0x22, 0x15, 0xe3, 0x65, 0x98, 0xb1, 0xcd, 0x80, 0x1b, 0xb6, 0xdb,
	0x7d, 0xa7, 0x65, 0x4a, 0xa8, 0x92, 0x21, 0x37, 0x01, 0xbc, 0x06, 0x99, 0x0e, 0xb3, 0x02, 0x6d,
	0xaa, 0x94, 0xae, 0xe4, 0xd7, 0xe7, 0xe5, 0x16, 0xbb, 0x1e, 0x75, 0x0c, 0x66, 0x91, 0x10, 0x54,
	0xfe, 0x90, 0x86, 0xe2, 0x73, 0xfa, 0x67, 0xf6, 0x77, 0x30, 0x79, 0x7f, 0x6b, 0x32, 0x41, 0xa2,
	0xe7, 0xbd, 0x2e, 0xf0, 0x5f, 0x98, 0xeb, 0xf6, 0x7d, 0x9f, 0x3a, 0xbc, 0xd5, 0xf7, 0x3c, 0x7b,
	0x20, 0x96, 0x18, 0x0f, 0x62, 0x1d, 0x40, 0x04, 0x0c, 0x66, 0x69, 0x53, 0x21, 0x24, 0x12, 0xc1,
	0x8b, 0x90, 0x73, 0xe8, 0x19, 0x6f, 0x71, 0xea, 0x69, 0xd9, 0x30, 0x3b, 0xfe, 0x3d, 0x16, 0x61,
	0xfa, 0x57, 0x44, 0xf8, 0x9a, 0x06, 0xb5, 0x45, 0x4d, 0x9b, 0x5a, 0x06, 0xb3, 0xee, 0xcf, 0xc3,
	0x72, 0xcb, 0x7b, 0x95, 0x40, 0x07, 0x38, 0x62, 0x7e, 0xdc, 0xc4, 0x91, 0x48, 0xdc, 0xe3, 0x53,
	0xb2, 0xc7, 0x4b, 0x90, 0xf7, 0xe9, 0x29, 0x35, 0xed, 0x61, 0x7e, 0xb8, 0xfd, 0x68, 0x08, 0x6f,
	0x00, 0x04, 0xa3, 0xf3, 0x8d, 0x64, 0x58, 0x98, 0xb8, 0x01, 0x12, 0x01, 0xe3, 0x27, 0x30, 0x3b,
	0x64, 0x12, 0xc5, 0xb9, 0x9f, 0x6b, 0x18, 0x03, 0x97, 0xdf, 0xa7, 0x61, 0x7a, 0x24, 0xe1, 0x06,
	0xcc, 0x98, 0x76, 0xcf, 0xf5, 0x19, 0x3f, 0x3e, 0x11, 0x2a, 0x2e, 0x4d, 0xd8, 0x56, 0x7b, 0xe0,
	0x51, 0x72, 0x83, 0xc6, 0x7b, 0xa0, 0x9a, 0xd2, 0x0d, 0x11, 0x32, 0x96, 0xee, 0xfa, 0x2b, 0xda,
	0x4c, 0x91, 0x44, 0xed, 0x39, 0x42, 0xb8, 0x0d, 0x45, 0x4b, 0xbe, 0x75, 0x42, 0xc3, 0x95, 0x3b,
	0xaf, 0xe7, 0x26, 0x22, 0xc9, 0xea, 0x6b, 0xd6, 0x3d, 0x50, 0x03, 0xc9, 0x47, 0xa1, 0x9a, 0xb7,
	0x0c, 0x2a, 0xfb, 0x6d, 0x53, 0x21, 0x89, 0xda, 0x73, 0x84, 0x8c, 0xbf, 0xa0, 0x78, 0x28, 0x1f,
	0xc0, 0xf8, 0x1b, 0xf0, 0x61, 0x62, 0x80, 0x10, 0x2a, 0x53, 0x94, 0x3f, 0x21, 0xc8, 0x47, 0x4c,
	0x88, 0x0b, 0xa0, 0x30, 0x2b, 0xdc, 0x7f, 0x86, 0x28, 0xcc, 0xba, 0xc5, 0xc9, 0xca, 0xef, 0x38,
	0xf9, 0x29, 0xcc, 0xd9, 0x26, 0xa7, 0x01, 0x1f, 0x1d, 0x3f, 0x17, 0xb2, 0xcd, 0x4f, 0x60, 0x23,
	0x71, 0xf4, 0x6a, 0x1d, 0x66, 0xa3, 0x37, 0x19, 0xcf, 0x42, 0xee, 0xd9, 0xee, 0x76, 0x73, 0xab,
	0xd1, 0x6e, 0xa8, 0x29, 0x9c, 0x87, 0x69, 0xb2, 0xbf, 0xb3, 0xf3, 0x72, 0xe7, 0x85, 0x8a, 0x30,
	0x40, 0x96, 0x34, 0x5e, 0x37, 0xea, 0x5b, 0xaa, 0x72, 0xfd, 0xbd, 0x59, 0x3f, 0xd8, 0xdd, 0x6f,
	0xab, 0x69, 0xe3, 0xd5, 0x97, 0x4b, 0x1d, 0x5d, 0x5c, 0xea, 0xe8, 0xfb, 0xa5, 0x8e, 0x3e, 0x5e,
	0xe9, 0xa9, 0x8b, 0x2b, 0x3d, 0xf5, 0xed, 0x4a, 0x4f, 0xbd, 0x7d, 0xd0, 0x63, 0xfc, 0xb8, 0xdf,
	0xa9, 0x76, 0xdd, 0x93, 0x5a, 0x2b, 0x1c, 0xe7, 0xff, 0x2d, 0xb3, 0x13, 0xd4, 0xc4, 0xab, 0x7a,
	0xfa, 0xb8, 0x76, 0x36, 0x7e, 0x5a, 0xf9, 0xc0, 0xa3, 0x41, 0x27, 0x1b, 0x3e, 0xab, 0x0f, 0x7f,
	0x04, 0x00, 0x00, 0xff, 0xff, 0xa6, 0xe0, 0x13, 0x1f, 0xfe, 0x07, 0x00, 0x00,
}

func (m *AscendingAuction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AscendingAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AscendingAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bids) > 0 {
		for iNdEx := len(m.Bids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuctionPool(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.LastBlock != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.LastBlock))
		i--
		dAtA[i] = 0x20
	}
	if m.PoolProperties != nil {
		{
			size, err := m.PoolProperties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuctionProperties != nil {
		{
			size, err := m.AuctionProperties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DescendingAuction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescendingAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DescendingAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bids) > 0 {
		for iNdEx := len(m.Bids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuctionPool(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.NextStep != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.NextStep))
		i--
		dAtA[i] = 0x30
	}
	if m.CurrentBid != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.CurrentBid))
		i--
		dAtA[i] = 0x28
	}
	if m.CurrentSupply != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.CurrentSupply))
		i--
		dAtA[i] = 0x20
	}
	if m.PoolProperties != nil {
		{
			size, err := m.PoolProperties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuctionProperties != nil {
		{
			size, err := m.AuctionProperties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SealedBidAuction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealedBidAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealedBidAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RevealedBids) > 0 {
		for iNdEx := len(m.RevealedBids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RevealedBids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuctionPool(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.SealedBids) > 0 {
		for iNdEx := len(m.SealedBids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SealedBids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuctionPool(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.RevealBlock != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.RevealBlock))
		i--
		dAtA[i] = 0x30
	}
	if m.LastBlock != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.LastBlock))
		i--
		dAtA[i] = 0x28
	}
	if m.FirstBlock != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.FirstBlock))
		i--
		dAtA[i] = 0x20
	}
	if m.PoolProperties != nil {
		{
			size, err := m.PoolProperties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuctionProperties != nil {
		{
			size, err := m.AuctionProperties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Auction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Auction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Auction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XSealedBidAuction != nil {
		{
			size := m.XSealedBidAuction.Size()
			i -= size
			if _, err := m.XSealedBidAuction.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.XDescendingAuction != nil {
		{
			size := m.XDescendingAuction.Size()
			i -= size
			if _, err := m.XDescendingAuction.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.XAscendingAuction != nil {
		{
			size := m.XAscendingAuction.Size()
			i -= size
			if _, err := m.XAscendingAuction.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Algorithm != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.Algorithm))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Auction_AscendingAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Auction_AscendingAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AscendingAuction != nil {
		{
			size, err := m.AscendingAuction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Auction_DescendingAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Auction_DescendingAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DescendingAuction != nil {
		{
			size, err := m.DescendingAuction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Auction_SealedBidAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Auction_SealedBidAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SealedBidAuction != nil {
		{
			size, err := m.SealedBidAuction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AuctionPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuctionPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LatestAuction != nil {
		{
			size, err := m.LatestAuction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.PoolProperties != nil {
		{
			size, err := m.PoolProperties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAuctionPool(dAtA []byte, offset int, v uint64) int {
	offset -= sovAuctionPool(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AscendingAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovAuctionPool(uint64(m.Status))
	}
	if m.AuctionProperties != nil {
		l = m.AuctionProperties.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	if m.PoolProperties != nil {
		l = m.PoolProperties.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	if m.LastBlock != 0 {
		n += 1 + sovAuctionPool(uint64(m.LastBlock))
	}
	if len(m.Bids) > 0 {
		for _, e := range m.Bids {
			l = e.Size()
			n += 1 + l + sovAuctionPool(uint64(l))
		}
	}
	return n
}

func (m *DescendingAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovAuctionPool(uint64(m.Status))
	}
	if m.AuctionProperties != nil {
		l = m.AuctionProperties.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	if m.PoolProperties != nil {
		l = m.PoolProperties.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	if m.CurrentSupply != 0 {
		n += 1 + sovAuctionPool(uint64(m.CurrentSupply))
	}
	if m.CurrentBid != 0 {
		n += 1 + sovAuctionPool(uint64(m.CurrentBid))
	}
	if m.NextStep != 0 {
		n += 1 + sovAuctionPool(uint64(m.NextStep))
	}
	if len(m.Bids) > 0 {
		for _, e := range m.Bids {
			l = e.Size()
			n += 1 + l + sovAuctionPool(uint64(l))
		}
	}
	return n
}

func (m *SealedBidAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovAuctionPool(uint64(m.Status))
	}
	if m.AuctionProperties != nil {
		l = m.AuctionProperties.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	if m.PoolProperties != nil {
		l = m.PoolProperties.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	if m.FirstBlock != 0 {
		n += 1 + sovAuctionPool(uint64(m.FirstBlock))
	}
	if m.LastBlock != 0 {
		n += 1 + sovAuctionPool(uint64(m.LastBlock))
	}
	if m.RevealBlock != 0 {
		n += 1 + sovAuctionPool(uint64(m.RevealBlock))
	}
	if len(m.SealedBids) > 0 {
		for _, e := range m.SealedBids {
			l = e.Size()
			n += 1 + l + sovAuctionPool(uint64(l))
		}
	}
	if len(m.RevealedBids) > 0 {
		for _, e := range m.RevealedBids {
			l = e.Size()
			n += 1 + l + sovAuctionPool(uint64(l))
		}
	}
	return n
}

func (m *Auction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algorithm != 0 {
		n += 1 + sovAuctionPool(uint64(m.Algorithm))
	}
	if m.XAscendingAuction != nil {
		n += m.XAscendingAuction.Size()
	}
	if m.XDescendingAuction != nil {
		n += m.XDescendingAuction.Size()
	}
	if m.XSealedBidAuction != nil {
		n += m.XSealedBidAuction.Size()
	}
	return n
}

func (m *Auction_AscendingAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AscendingAuction != nil {
		l = m.AscendingAuction.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	return n
}
func (m *Auction_DescendingAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescendingAuction != nil {
		l = m.DescendingAuction.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	return n
}
func (m *Auction_SealedBidAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SealedBidAuction != nil {
		l = m.SealedBidAuction.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	return n
}
func (m *AuctionPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAuctionPool(uint64(m.Id))
	}
	if m.PoolProperties != nil {
		l = m.PoolProperties.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	if m.LatestAuction != nil {
		l = m.LatestAuction.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	return n
}

func sovAuctionPool(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAuctionPool(x uint64) (n int) {
	return sovAuctionPool(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AscendingAuction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuctionPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AscendingAuction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AscendingAuction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AuctionState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionProperties == nil {
				m.AuctionProperties = &AscendingAuctionProperties{}
			}
			if err := m.AuctionProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PoolProperties == nil {
				m.PoolProperties = &AuctionPoolProperties{}
			}
			if err := m.PoolProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlock", wireType)
			}
			m.LastBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bids = append(m.Bids, &OpenBid{})
			if err := m.Bids[len(m.Bids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuctionPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescendingAuction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuctionPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescendingAuction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescendingAuction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AuctionState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionProperties == nil {
				m.AuctionProperties = &DescendingAuctionProperties{}
			}
			if err := m.AuctionProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PoolProperties == nil {
				m.PoolProperties = &AuctionPoolProperties{}
			}
			if err := m.PoolProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSupply", wireType)
			}
			m.CurrentSupply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentSupply |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBid", wireType)
			}
			m.CurrentBid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentBid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			m.NextStep = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextStep |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bids = append(m.Bids, &OpenBid{})
			if err := m.Bids[len(m.Bids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuctionPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealedBidAuction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuctionPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealedBidAuction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealedBidAuction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AuctionState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionProperties == nil {
				m.AuctionProperties = &SealedBidAuctionProperties{}
			}
			if err := m.AuctionProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PoolProperties == nil {
				m.PoolProperties = &AuctionPoolProperties{}
			}
			if err := m.PoolProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstBlock", wireType)
			}
			m.FirstBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlock", wireType)
			}
			m.LastBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevealBlock", wireType)
			}
			m.RevealBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevealBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealedBids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SealedBids = append(m.SealedBids, &SealedBid{})
			if err := m.SealedBids[len(m.SealedBids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevealedBids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RevealedBids = append(m.RevealedBids, &OpenBid{})
			if err := m.RevealedBids[len(m.RevealedBids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuctionPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Auction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuctionPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Auction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Auction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= AuctionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AscendingAuction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AscendingAuction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.XAscendingAuction = &Auction_AscendingAuction{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescendingAuction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DescendingAuction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.XDescendingAuction = &Auction_DescendingAuction{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealedBidAuction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SealedBidAuction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.XSealedBidAuction = &Auction_SealedBidAuction{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuctionPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuctionPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PoolProperties == nil {
				m.PoolProperties = &AuctionPoolProperties{}
			}
			if err := m.PoolProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestAuction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LatestAuction == nil {
				m.LatestAuction = &Auction{}
			}
			if err := m.LatestAuction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuctionPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuctionPool(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuctionPool
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAuctionPool
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAuctionPool
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAuctionPool
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAuctionPool        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuctionPool          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAuctionPool = fmt.Errorf("proto: unexpected end of group")
)

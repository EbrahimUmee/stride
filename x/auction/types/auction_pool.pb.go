// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stride/auction/auction_pool.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AuctionType int32

const (
	AuctionType_UNKNOWN    AuctionType = 0
	AuctionType_ASCENDING  AuctionType = 1
	AuctionType_DESCENDING AuctionType = 2
	AuctionType_SEALEDBID  AuctionType = 3
)

var AuctionType_name = map[int32]string{
	0: "UNKNOWN",
	1: "ASCENDING",
	2: "DESCENDING",
	3: "SEALEDBID",
}

var AuctionType_value = map[string]int32{
	"UNKNOWN":    0,
	"ASCENDING":  1,
	"DESCENDING": 2,
	"SEALEDBID":  3,
}

func (x AuctionType) String() string {
	return proto.EnumName(AuctionType_name, int32(x))
}

func (AuctionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e7c158d68ebb3589, []int{0}
}

type AuctionState int32

const (
	AuctionState_COMPLETE AuctionState = 0
	AuctionState_RUNNING  AuctionState = 1
	AuctionState_REVEAL   AuctionState = 2
	AuctionState_PAYOUT   AuctionState = 3
)

var AuctionState_name = map[int32]string{
	0: "COMPLETE",
	1: "RUNNING",
	2: "REVEAL",
	3: "PAYOUT",
}

var AuctionState_value = map[string]int32{
	"COMPLETE": 0,
	"RUNNING":  1,
	"REVEAL":   2,
	"PAYOUT":   3,
}

func (x AuctionState) String() string {
	return proto.EnumName(AuctionState_name, int32(x))
}

func (AuctionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e7c158d68ebb3589, []int{1}
}

// English style auction specific parameters
// Starts low with increasing bids, auction ends if no new bids occur
// for endDuration blocks in a row and goes to current winner
// When a higher bid comes in, the lastBlock is set now + endDuration
type AscendingAuction struct {
	Status        AuctionState `protobuf:"varint,1,opt,name=status,proto3,enum=stride.auction.AuctionState" json:"status,omitempty"`
	Target        string       `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	Supply        uint64       `protobuf:"varint,3,opt,name=supply,proto3" json:"supply,omitempty"`
	MinAllowedBid uint64       `protobuf:"varint,4,opt,name=minAllowedBid,proto3" json:"minAllowedBid,omitempty"`
	MaxAllowedBid uint64       `protobuf:"varint,5,opt,name=maxAllowedBid,proto3" json:"maxAllowedBid,omitempty"`
	EndDuration   uint64       `protobuf:"varint,6,opt,name=endDuration,proto3" json:"endDuration,omitempty"`
	LastBlock     uint64       `protobuf:"varint,7,opt,name=lastBlock,proto3" json:"lastBlock,omitempty"`
	CurrentBid    uint64       `protobuf:"varint,8,opt,name=currentBid,proto3" json:"currentBid,omitempty"`
	CurrentWinner string       `protobuf:"bytes,9,opt,name=currentWinner,proto3" json:"currentWinner,omitempty"`
}

func (m *AscendingAuction) Reset()         { *m = AscendingAuction{} }
func (m *AscendingAuction) String() string { return proto.CompactTextString(m) }
func (*AscendingAuction) ProtoMessage()    {}
func (*AscendingAuction) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7c158d68ebb3589, []int{0}
}
func (m *AscendingAuction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AscendingAuction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AscendingAuction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AscendingAuction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AscendingAuction.Merge(m, src)
}
func (m *AscendingAuction) XXX_Size() int {
	return m.Size()
}
func (m *AscendingAuction) XXX_DiscardUnknown() {
	xxx_messageInfo_AscendingAuction.DiscardUnknown(m)
}

var xxx_messageInfo_AscendingAuction proto.InternalMessageInfo

func (m *AscendingAuction) GetStatus() AuctionState {
	if m != nil {
		return m.Status
	}
	return AuctionState_COMPLETE
}

func (m *AscendingAuction) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *AscendingAuction) GetSupply() uint64 {
	if m != nil {
		return m.Supply
	}
	return 0
}

func (m *AscendingAuction) GetMinAllowedBid() uint64 {
	if m != nil {
		return m.MinAllowedBid
	}
	return 0
}

func (m *AscendingAuction) GetMaxAllowedBid() uint64 {
	if m != nil {
		return m.MaxAllowedBid
	}
	return 0
}

func (m *AscendingAuction) GetEndDuration() uint64 {
	if m != nil {
		return m.EndDuration
	}
	return 0
}

func (m *AscendingAuction) GetLastBlock() uint64 {
	if m != nil {
		return m.LastBlock
	}
	return 0
}

func (m *AscendingAuction) GetCurrentBid() uint64 {
	if m != nil {
		return m.CurrentBid
	}
	return 0
}

func (m *AscendingAuction) GetCurrentWinner() string {
	if m != nil {
		return m.CurrentWinner
	}
	return ""
}

// Dutch style auction specific parameters
// Starts high at startingBid, moves bid down bidStepSize each
// bidStepDuration blocks until someone is willing to bid and win
type DescendingAuction struct {
	Status          AuctionState `protobuf:"varint,1,opt,name=status,proto3,enum=stride.auction.AuctionState" json:"status,omitempty"`
	Target          string       `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	Supply          uint64       `protobuf:"varint,3,opt,name=supply,proto3" json:"supply,omitempty"`
	MinAllowedBid   uint64       `protobuf:"varint,4,opt,name=minAllowedBid,proto3" json:"minAllowedBid,omitempty"`
	MaxAllowedBid   uint64       `protobuf:"varint,5,opt,name=maxAllowedBid,proto3" json:"maxAllowedBid,omitempty"`
	StartingBid     uint64       `protobuf:"varint,6,opt,name=startingBid,proto3" json:"startingBid,omitempty"`
	CurrentBid      uint64       `protobuf:"varint,7,opt,name=currentBid,proto3" json:"currentBid,omitempty"`
	BidStepSize     uint64       `protobuf:"varint,8,opt,name=bidStepSize,proto3" json:"bidStepSize,omitempty"`
	BidStepDuration uint64       `protobuf:"varint,9,opt,name=bidStepDuration,proto3" json:"bidStepDuration,omitempty"`
	NextStep        uint64       `protobuf:"varint,10,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
}

func (m *DescendingAuction) Reset()         { *m = DescendingAuction{} }
func (m *DescendingAuction) String() string { return proto.CompactTextString(m) }
func (*DescendingAuction) ProtoMessage()    {}
func (*DescendingAuction) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7c158d68ebb3589, []int{1}
}
func (m *DescendingAuction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DescendingAuction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DescendingAuction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DescendingAuction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescendingAuction.Merge(m, src)
}
func (m *DescendingAuction) XXX_Size() int {
	return m.Size()
}
func (m *DescendingAuction) XXX_DiscardUnknown() {
	xxx_messageInfo_DescendingAuction.DiscardUnknown(m)
}

var xxx_messageInfo_DescendingAuction proto.InternalMessageInfo

func (m *DescendingAuction) GetStatus() AuctionState {
	if m != nil {
		return m.Status
	}
	return AuctionState_COMPLETE
}

func (m *DescendingAuction) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *DescendingAuction) GetSupply() uint64 {
	if m != nil {
		return m.Supply
	}
	return 0
}

func (m *DescendingAuction) GetMinAllowedBid() uint64 {
	if m != nil {
		return m.MinAllowedBid
	}
	return 0
}

func (m *DescendingAuction) GetMaxAllowedBid() uint64 {
	if m != nil {
		return m.MaxAllowedBid
	}
	return 0
}

func (m *DescendingAuction) GetStartingBid() uint64 {
	if m != nil {
		return m.StartingBid
	}
	return 0
}

func (m *DescendingAuction) GetCurrentBid() uint64 {
	if m != nil {
		return m.CurrentBid
	}
	return 0
}

func (m *DescendingAuction) GetBidStepSize() uint64 {
	if m != nil {
		return m.BidStepSize
	}
	return 0
}

func (m *DescendingAuction) GetBidStepDuration() uint64 {
	if m != nil {
		return m.BidStepDuration
	}
	return 0
}

func (m *DescendingAuction) GetNextStep() uint64 {
	if m != nil {
		return m.NextStep
	}
	return 0
}

// Sealed Bid style auction specific parameters
// Auction is open for sealed bids from firstBlock to lastBlock
// after last block but before revealBlock send same bids unsealed
type SealedBidAuction struct {
	Status          AuctionState `protobuf:"varint,1,opt,name=status,proto3,enum=stride.auction.AuctionState" json:"status,omitempty"`
	Target          string       `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	Supply          uint64       `protobuf:"varint,3,opt,name=supply,proto3" json:"supply,omitempty"`
	MinAllowedBid   uint64       `protobuf:"varint,4,opt,name=minAllowedBid,proto3" json:"minAllowedBid,omitempty"`
	MaxAllowedBid   uint64       `protobuf:"varint,5,opt,name=maxAllowedBid,proto3" json:"maxAllowedBid,omitempty"`
	AuctionDuration uint64       `protobuf:"varint,6,opt,name=auctionDuration,proto3" json:"auctionDuration,omitempty"`
	RevealDuration  uint64       `protobuf:"varint,7,opt,name=revealDuration,proto3" json:"revealDuration,omitempty"`
	FirstBlock      uint64       `protobuf:"varint,8,opt,name=firstBlock,proto3" json:"firstBlock,omitempty"`
	LastBlock       uint64       `protobuf:"varint,9,opt,name=lastBlock,proto3" json:"lastBlock,omitempty"`
	RevealBlock     uint64       `protobuf:"varint,10,opt,name=revealBlock,proto3" json:"revealBlock,omitempty"`
}

func (m *SealedBidAuction) Reset()         { *m = SealedBidAuction{} }
func (m *SealedBidAuction) String() string { return proto.CompactTextString(m) }
func (*SealedBidAuction) ProtoMessage()    {}
func (*SealedBidAuction) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7c158d68ebb3589, []int{2}
}
func (m *SealedBidAuction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealedBidAuction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealedBidAuction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealedBidAuction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealedBidAuction.Merge(m, src)
}
func (m *SealedBidAuction) XXX_Size() int {
	return m.Size()
}
func (m *SealedBidAuction) XXX_DiscardUnknown() {
	xxx_messageInfo_SealedBidAuction.DiscardUnknown(m)
}

var xxx_messageInfo_SealedBidAuction proto.InternalMessageInfo

func (m *SealedBidAuction) GetStatus() AuctionState {
	if m != nil {
		return m.Status
	}
	return AuctionState_COMPLETE
}

func (m *SealedBidAuction) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *SealedBidAuction) GetSupply() uint64 {
	if m != nil {
		return m.Supply
	}
	return 0
}

func (m *SealedBidAuction) GetMinAllowedBid() uint64 {
	if m != nil {
		return m.MinAllowedBid
	}
	return 0
}

func (m *SealedBidAuction) GetMaxAllowedBid() uint64 {
	if m != nil {
		return m.MaxAllowedBid
	}
	return 0
}

func (m *SealedBidAuction) GetAuctionDuration() uint64 {
	if m != nil {
		return m.AuctionDuration
	}
	return 0
}

func (m *SealedBidAuction) GetRevealDuration() uint64 {
	if m != nil {
		return m.RevealDuration
	}
	return 0
}

func (m *SealedBidAuction) GetFirstBlock() uint64 {
	if m != nil {
		return m.FirstBlock
	}
	return 0
}

func (m *SealedBidAuction) GetLastBlock() uint64 {
	if m != nil {
		return m.LastBlock
	}
	return 0
}

func (m *SealedBidAuction) GetRevealBlock() uint64 {
	if m != nil {
		return m.RevealBlock
	}
	return 0
}

// Would be more elegant if protobuf had a nice way to do interfaces but
// the algorithm is used to determine which one of the optional fields is set
type Auction struct {
	Algorithm AuctionType `protobuf:"varint,1,opt,name=algorithm,proto3,enum=stride.auction.AuctionType" json:"algorithm,omitempty"`
	// Types that are valid to be assigned to XAscendingAuction:
	//	*Auction_AscendingAuction
	XAscendingAuction isAuction_XAscendingAuction `protobuf_oneof:"_ascendingAuction"`
	// Types that are valid to be assigned to XDescendingAuction:
	//	*Auction_DescendingAuction
	XDescendingAuction isAuction_XDescendingAuction `protobuf_oneof:"_descendingAuction"`
	// Types that are valid to be assigned to XSealedBidAuction:
	//	*Auction_SealedBidAuction
	XSealedBidAuction isAuction_XSealedBidAuction `protobuf_oneof:"_sealedBidAuction"`
}

func (m *Auction) Reset()         { *m = Auction{} }
func (m *Auction) String() string { return proto.CompactTextString(m) }
func (*Auction) ProtoMessage()    {}
func (*Auction) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7c158d68ebb3589, []int{3}
}
func (m *Auction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Auction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Auction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Auction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Auction.Merge(m, src)
}
func (m *Auction) XXX_Size() int {
	return m.Size()
}
func (m *Auction) XXX_DiscardUnknown() {
	xxx_messageInfo_Auction.DiscardUnknown(m)
}

var xxx_messageInfo_Auction proto.InternalMessageInfo

type isAuction_XAscendingAuction interface {
	isAuction_XAscendingAuction()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAuction_XDescendingAuction interface {
	isAuction_XDescendingAuction()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAuction_XSealedBidAuction interface {
	isAuction_XSealedBidAuction()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Auction_AscendingAuction struct {
	AscendingAuction *AscendingAuction `protobuf:"bytes,2,opt,name=ascendingAuction,proto3,oneof" json:"ascendingAuction,omitempty"`
}
type Auction_DescendingAuction struct {
	DescendingAuction *DescendingAuction `protobuf:"bytes,3,opt,name=descendingAuction,proto3,oneof" json:"descendingAuction,omitempty"`
}
type Auction_SealedBidAuction struct {
	SealedBidAuction *SealedBidAuction `protobuf:"bytes,4,opt,name=sealedBidAuction,proto3,oneof" json:"sealedBidAuction,omitempty"`
}

func (*Auction_AscendingAuction) isAuction_XAscendingAuction()   {}
func (*Auction_DescendingAuction) isAuction_XDescendingAuction() {}
func (*Auction_SealedBidAuction) isAuction_XSealedBidAuction()   {}

func (m *Auction) GetXAscendingAuction() isAuction_XAscendingAuction {
	if m != nil {
		return m.XAscendingAuction
	}
	return nil
}
func (m *Auction) GetXDescendingAuction() isAuction_XDescendingAuction {
	if m != nil {
		return m.XDescendingAuction
	}
	return nil
}
func (m *Auction) GetXSealedBidAuction() isAuction_XSealedBidAuction {
	if m != nil {
		return m.XSealedBidAuction
	}
	return nil
}

func (m *Auction) GetAlgorithm() AuctionType {
	if m != nil {
		return m.Algorithm
	}
	return AuctionType_UNKNOWN
}

func (m *Auction) GetAscendingAuction() *AscendingAuction {
	if x, ok := m.GetXAscendingAuction().(*Auction_AscendingAuction); ok {
		return x.AscendingAuction
	}
	return nil
}

func (m *Auction) GetDescendingAuction() *DescendingAuction {
	if x, ok := m.GetXDescendingAuction().(*Auction_DescendingAuction); ok {
		return x.DescendingAuction
	}
	return nil
}

func (m *Auction) GetSealedBidAuction() *SealedBidAuction {
	if x, ok := m.GetXSealedBidAuction().(*Auction_SealedBidAuction); ok {
		return x.SealedBidAuction
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Auction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Auction_AscendingAuction)(nil),
		(*Auction_DescendingAuction)(nil),
		(*Auction_SealedBidAuction)(nil),
	}
}

// Auction Pool has an address with some assets and restrictions on the types
// of auctions which can be run for this pool.
type AuctionPool struct {
	Id                uint64        `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	PoolAddress       string        `protobuf:"bytes,2,opt,name=poolAddress,proto3" json:"poolAddress,omitempty"`
	MinAllowedSupply  uint64        `protobuf:"varint,3,opt,name=minAllowedSupply,proto3" json:"minAllowedSupply,omitempty"`
	MaxAllowedSupply  uint64        `protobuf:"varint,4,opt,name=maxAllowedSupply,proto3" json:"maxAllowedSupply,omitempty"`
	AllowedAlgorithms []AuctionType `protobuf:"varint,5,rep,packed,name=allowedAlgorithms,proto3,enum=stride.auction.AuctionType" json:"allowedAlgorithms,omitempty"`
	LatestAuction     *Auction      `protobuf:"bytes,6,opt,name=latestAuction,proto3" json:"latestAuction,omitempty"`
}

func (m *AuctionPool) Reset()         { *m = AuctionPool{} }
func (m *AuctionPool) String() string { return proto.CompactTextString(m) }
func (*AuctionPool) ProtoMessage()    {}
func (*AuctionPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7c158d68ebb3589, []int{4}
}
func (m *AuctionPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuctionPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuctionPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuctionPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuctionPool.Merge(m, src)
}
func (m *AuctionPool) XXX_Size() int {
	return m.Size()
}
func (m *AuctionPool) XXX_DiscardUnknown() {
	xxx_messageInfo_AuctionPool.DiscardUnknown(m)
}

var xxx_messageInfo_AuctionPool proto.InternalMessageInfo

func (m *AuctionPool) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AuctionPool) GetPoolAddress() string {
	if m != nil {
		return m.PoolAddress
	}
	return ""
}

func (m *AuctionPool) GetMinAllowedSupply() uint64 {
	if m != nil {
		return m.MinAllowedSupply
	}
	return 0
}

func (m *AuctionPool) GetMaxAllowedSupply() uint64 {
	if m != nil {
		return m.MaxAllowedSupply
	}
	return 0
}

func (m *AuctionPool) GetAllowedAlgorithms() []AuctionType {
	if m != nil {
		return m.AllowedAlgorithms
	}
	return nil
}

func (m *AuctionPool) GetLatestAuction() *Auction {
	if m != nil {
		return m.LatestAuction
	}
	return nil
}

func init() {
	proto.RegisterEnum("stride.auction.AuctionType", AuctionType_name, AuctionType_value)
	proto.RegisterEnum("stride.auction.AuctionState", AuctionState_name, AuctionState_value)
	proto.RegisterType((*AscendingAuction)(nil), "stride.auction.AscendingAuction")
	proto.RegisterType((*DescendingAuction)(nil), "stride.auction.DescendingAuction")
	proto.RegisterType((*SealedBidAuction)(nil), "stride.auction.SealedBidAuction")
	proto.RegisterType((*Auction)(nil), "stride.auction.Auction")
	proto.RegisterType((*AuctionPool)(nil), "stride.auction.AuctionPool")
}

func init() { proto.RegisterFile("stride/auction/auction_pool.proto", fileDescriptor_e7c158d68ebb3589) }

var fileDescriptor_e7c158d68ebb3589 = []byte{
	// 768 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x55, 0x41, 0x6f, 0xda, 0x48,
	0x14, 0xc6, 0x86, 0x40, 0x78, 0x24, 0xc4, 0xcc, 0xae, 0x76, 0xbd, 0xd9, 0x08, 0x39, 0x68, 0xb5,
	0x42, 0x91, 0x16, 0x56, 0xd9, 0xdd, 0xc3, 0x1e, 0x7a, 0x30, 0xc1, 0x2a, 0x69, 0x29, 0x49, 0x6c,
	0xd2, 0xa8, 0xbd, 0x44, 0x03, 0x9e, 0x10, 0xab, 0x8e, 0x8d, 0xec, 0x21, 0x0d, 0x3d, 0xf5, 0x98,
	0x63, 0xff, 0x42, 0xff, 0x4d, 0xd5, 0x53, 0x8e, 0x3d, 0x56, 0xc9, 0x0f, 0xe8, 0xad, 0xe7, 0xca,
	0xe3, 0x01, 0xcc, 0xb8, 0x51, 0xcf, 0xed, 0x09, 0xbf, 0xef, 0x7d, 0xf3, 0xfc, 0xfc, 0xbd, 0xef,
	0x31, 0xb0, 0x1d, 0xd2, 0xc0, 0xb1, 0x49, 0x13, 0x4f, 0x86, 0xd4, 0xf1, 0xbd, 0xd9, 0xef, 0xe9,
	0xd8, 0xf7, 0xdd, 0xc6, 0x38, 0xf0, 0xa9, 0x8f, 0xca, 0x31, 0xa5, 0xc1, 0x53, 0x9b, 0xbf, 0x8d,
	0x7c, 0x7f, 0xe4, 0x92, 0x26, 0xcb, 0x0e, 0x26, 0x67, 0x4d, 0xec, 0x4d, 0x63, 0x6a, 0xed, 0xbd,
	0x0c, 0x8a, 0x1e, 0x0e, 0x89, 0x67, 0x3b, 0xde, 0x48, 0x8f, 0xf9, 0xe8, 0x5f, 0xc8, 0x87, 0x14,
	0xd3, 0x49, 0xa8, 0x4a, 0x9a, 0x54, 0x2f, 0xef, 0x6e, 0x35, 0x96, 0x0b, 0x36, 0x38, 0xd1, 0xa2,
	0x98, 0x12, 0x93, 0x73, 0xd1, 0x2f, 0x90, 0xa7, 0x38, 0x18, 0x11, 0xaa, 0xca, 0x9a, 0x54, 0x2f,
	0x9a, 0x3c, 0x8a, 0xf0, 0x70, 0x32, 0x1e, 0xbb, 0x53, 0x35, 0xab, 0x49, 0xf5, 0x9c, 0xc9, 0x23,
	0xf4, 0x07, 0xac, 0x5f, 0x38, 0x9e, 0xee, 0xba, 0xfe, 0x4b, 0x62, 0xb7, 0x1c, 0x5b, 0xcd, 0xb1,
	0xf4, 0x32, 0xc8, 0x58, 0xf8, 0x2a, 0xc1, 0x5a, 0xe1, 0xac, 0x24, 0x88, 0x34, 0x28, 0x11, 0xcf,
	0x6e, 0x4f, 0x02, 0x1c, 0xf5, 0xa5, 0xe6, 0x19, 0x27, 0x09, 0xa1, 0x2d, 0x28, 0xba, 0x38, 0xa4,
	0x2d, 0xd7, 0x1f, 0xbe, 0x50, 0x0b, 0x2c, 0xbf, 0x00, 0x50, 0x15, 0x60, 0x38, 0x09, 0x02, 0xe2,
	0xd1, 0xe8, 0x15, 0xab, 0x2c, 0x9d, 0x40, 0xa2, 0x2e, 0x78, 0x74, 0xe2, 0x78, 0x1e, 0x09, 0xd4,
	0x22, 0xfb, 0xc4, 0x65, 0xb0, 0xf6, 0x49, 0x86, 0x4a, 0x9b, 0xfc, 0x10, 0x6a, 0x86, 0x14, 0x07,
	0xd4, 0xf1, 0x46, 0x11, 0x87, 0xab, 0x99, 0x80, 0x04, 0xbd, 0x0a, 0x29, 0xbd, 0x34, 0x28, 0x0d,
	0x1c, 0xdb, 0xa2, 0x64, 0x6c, 0x39, 0xaf, 0x08, 0x17, 0x34, 0x09, 0xa1, 0x3a, 0x6c, 0xf0, 0x70,
	0x3e, 0xb5, 0x22, 0x63, 0x89, 0x30, 0xda, 0x84, 0x55, 0x8f, 0x5c, 0xd1, 0x08, 0x53, 0x81, 0x51,
	0xe6, 0x71, 0xed, 0xb3, 0x0c, 0x8a, 0x45, 0xb0, 0xcb, 0xfa, 0xfe, 0x7e, 0x05, 0xaf, 0xc3, 0x06,
	0xef, 0x4d, 0xb0, 0xb0, 0x08, 0xa3, 0x3f, 0xa1, 0x1c, 0x90, 0x4b, 0x82, 0xdd, 0x39, 0x31, 0x16,
	0x5f, 0x40, 0xa3, 0x01, 0x9d, 0x39, 0xc1, 0xcc, 0xef, 0xdc, 0xd0, 0x0b, 0x64, 0x79, 0x1d, 0x8a,
	0xe2, 0x3a, 0x68, 0x50, 0x8a, 0xeb, 0xc5, 0xf9, 0x58, 0xf5, 0x24, 0x54, 0x7b, 0x9d, 0x85, 0xc2,
	0x4c, 0xef, 0xff, 0xa1, 0x88, 0xdd, 0x91, 0x1f, 0x38, 0xf4, 0xfc, 0x82, 0x4b, 0xfe, 0xfb, 0x3d,
	0x92, 0xf7, 0xa7, 0x63, 0x62, 0x2e, 0xd8, 0xe8, 0x08, 0x14, 0x2c, 0xec, 0x0b, 0x93, 0xbf, 0xb4,
	0xab, 0xa5, 0x2a, 0x08, 0xbc, 0x4e, 0xc6, 0x4c, 0x9d, 0xbd, 0x96, 0x24, 0xd4, 0x87, 0x8a, 0x2d,
	0xee, 0x20, 0x1b, 0x5d, 0x69, 0x77, 0x5b, 0xac, 0x99, 0x5a, 0xd6, 0x8e, 0x64, 0xa6, 0x4f, 0x47,
	0x55, 0x8f, 0x40, 0x09, 0x05, 0x9f, 0xb1, 0x81, 0x7f, 0xa5, 0x51, 0xd1, 0x8f, 0x1d, 0xd9, 0x4c,
	0x9d, 0xbd, 0x96, 0xa4, 0xd6, 0x4f, 0x50, 0x39, 0x15, 0x3f, 0xa0, 0xf5, 0x33, 0xa0, 0xd3, 0x54,
	0x03, 0x8c, 0x2a, 0x96, 0xa8, 0xbd, 0x95, 0xa1, 0xc4, 0x9f, 0x0f, 0x7d, 0xdf, 0x45, 0x65, 0x90,
	0x1d, 0x9b, 0xe9, 0x9f, 0x33, 0xe5, 0x78, 0x07, 0xa3, 0x3b, 0x41, 0xb7, 0xed, 0x80, 0x84, 0x21,
	0x77, 0x75, 0x12, 0x42, 0x3b, 0xa0, 0x2c, 0xdc, 0x6a, 0x25, 0x4d, 0x9e, 0xc2, 0x19, 0x77, 0xee,
	0x59, 0xce, 0xcd, 0x71, 0xae, 0x80, 0xa3, 0x7d, 0xa8, 0xe0, 0x18, 0xd0, 0x67, 0x93, 0x0e, 0xd5,
	0x15, 0x2d, 0xfb, 0x2d, 0x63, 0xa4, 0x4f, 0xa1, 0x07, 0xb0, 0xee, 0x62, 0x4a, 0x42, 0x3a, 0x13,
	0x3d, 0xcf, 0x44, 0xff, 0xf5, 0x9e, 0x32, 0xe6, 0x32, 0x7b, 0xa7, 0x33, 0x97, 0x28, 0x7a, 0x01,
	0x2a, 0x41, 0xe1, 0xb8, 0xf7, 0xb8, 0x77, 0x70, 0xd2, 0x53, 0x32, 0x68, 0x1d, 0x8a, 0xba, 0xb5,
	0x67, 0xf4, 0xda, 0xfb, 0xbd, 0x87, 0x8a, 0x84, 0xca, 0x00, 0x6d, 0x63, 0x1e, 0xcb, 0x51, 0xda,
	0x32, 0xf4, 0xae, 0xd1, 0x6e, 0xed, 0xb7, 0x95, 0xec, 0x8e, 0x0e, 0x6b, 0xc9, 0xbf, 0x0d, 0xb4,
	0x06, 0xab, 0x7b, 0x07, 0x4f, 0x0e, 0xbb, 0x46, 0xdf, 0x50, 0x32, 0x51, 0x61, 0xf3, 0xb8, 0xd7,
	0x8b, 0x2b, 0x01, 0xe4, 0x4d, 0xe3, 0xa9, 0xa1, 0x77, 0x15, 0x39, 0x7a, 0x3e, 0xd4, 0x9f, 0x1d,
	0x1c, 0xf7, 0x95, 0x6c, 0xeb, 0xd1, 0xbb, 0xdb, 0xaa, 0x74, 0x73, 0x5b, 0x95, 0x3e, 0xde, 0x56,
	0xa5, 0x37, 0x77, 0xd5, 0xcc, 0xcd, 0x5d, 0x35, 0xf3, 0xe1, 0xae, 0x9a, 0x79, 0xfe, 0xf7, 0xc8,
	0xa1, 0xe7, 0x93, 0x41, 0x63, 0xe8, 0x5f, 0x34, 0x2d, 0xf6, 0x61, 0x7f, 0x75, 0xf1, 0x20, 0x6c,
	0xf2, 0xab, 0xfe, 0xf2, 0xbf, 0xe6, 0xd5, 0xfc, 0xbe, 0xa7, 0xd3, 0x31, 0x09, 0x07, 0x79, 0x76,
	0x7d, 0xff, 0xf3, 0x25, 0x00, 0x00, 0xff, 0xff, 0x6c, 0x91, 0xd4, 0xa1, 0x0e, 0x08, 0x00, 0x00,
}

func (m *AscendingAuction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AscendingAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AscendingAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CurrentWinner) > 0 {
		i -= len(m.CurrentWinner)
		copy(dAtA[i:], m.CurrentWinner)
		i = encodeVarintAuctionPool(dAtA, i, uint64(len(m.CurrentWinner)))
		i--
		dAtA[i] = 0x4a
	}
	if m.CurrentBid != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.CurrentBid))
		i--
		dAtA[i] = 0x40
	}
	if m.LastBlock != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.LastBlock))
		i--
		dAtA[i] = 0x38
	}
	if m.EndDuration != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.EndDuration))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxAllowedBid != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.MaxAllowedBid))
		i--
		dAtA[i] = 0x28
	}
	if m.MinAllowedBid != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.MinAllowedBid))
		i--
		dAtA[i] = 0x20
	}
	if m.Supply != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.Supply))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintAuctionPool(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DescendingAuction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescendingAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DescendingAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextStep != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.NextStep))
		i--
		dAtA[i] = 0x50
	}
	if m.BidStepDuration != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.BidStepDuration))
		i--
		dAtA[i] = 0x48
	}
	if m.BidStepSize != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.BidStepSize))
		i--
		dAtA[i] = 0x40
	}
	if m.CurrentBid != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.CurrentBid))
		i--
		dAtA[i] = 0x38
	}
	if m.StartingBid != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.StartingBid))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxAllowedBid != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.MaxAllowedBid))
		i--
		dAtA[i] = 0x28
	}
	if m.MinAllowedBid != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.MinAllowedBid))
		i--
		dAtA[i] = 0x20
	}
	if m.Supply != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.Supply))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintAuctionPool(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SealedBidAuction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealedBidAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealedBidAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RevealBlock != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.RevealBlock))
		i--
		dAtA[i] = 0x50
	}
	if m.LastBlock != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.LastBlock))
		i--
		dAtA[i] = 0x48
	}
	if m.FirstBlock != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.FirstBlock))
		i--
		dAtA[i] = 0x40
	}
	if m.RevealDuration != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.RevealDuration))
		i--
		dAtA[i] = 0x38
	}
	if m.AuctionDuration != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.AuctionDuration))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxAllowedBid != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.MaxAllowedBid))
		i--
		dAtA[i] = 0x28
	}
	if m.MinAllowedBid != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.MinAllowedBid))
		i--
		dAtA[i] = 0x20
	}
	if m.Supply != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.Supply))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintAuctionPool(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Auction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Auction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Auction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XSealedBidAuction != nil {
		{
			size := m.XSealedBidAuction.Size()
			i -= size
			if _, err := m.XSealedBidAuction.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.XDescendingAuction != nil {
		{
			size := m.XDescendingAuction.Size()
			i -= size
			if _, err := m.XDescendingAuction.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.XAscendingAuction != nil {
		{
			size := m.XAscendingAuction.Size()
			i -= size
			if _, err := m.XAscendingAuction.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Algorithm != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.Algorithm))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Auction_AscendingAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Auction_AscendingAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AscendingAuction != nil {
		{
			size, err := m.AscendingAuction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Auction_DescendingAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Auction_DescendingAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DescendingAuction != nil {
		{
			size, err := m.DescendingAuction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Auction_SealedBidAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Auction_SealedBidAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SealedBidAuction != nil {
		{
			size, err := m.SealedBidAuction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AuctionPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuctionPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LatestAuction != nil {
		{
			size, err := m.LatestAuction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuctionPool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.AllowedAlgorithms) > 0 {
		dAtA6 := make([]byte, len(m.AllowedAlgorithms)*10)
		var j5 int
		for _, num := range m.AllowedAlgorithms {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintAuctionPool(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x2a
	}
	if m.MaxAllowedSupply != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.MaxAllowedSupply))
		i--
		dAtA[i] = 0x20
	}
	if m.MinAllowedSupply != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.MinAllowedSupply))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PoolAddress) > 0 {
		i -= len(m.PoolAddress)
		copy(dAtA[i:], m.PoolAddress)
		i = encodeVarintAuctionPool(dAtA, i, uint64(len(m.PoolAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintAuctionPool(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAuctionPool(dAtA []byte, offset int, v uint64) int {
	offset -= sovAuctionPool(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AscendingAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovAuctionPool(uint64(m.Status))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	if m.Supply != 0 {
		n += 1 + sovAuctionPool(uint64(m.Supply))
	}
	if m.MinAllowedBid != 0 {
		n += 1 + sovAuctionPool(uint64(m.MinAllowedBid))
	}
	if m.MaxAllowedBid != 0 {
		n += 1 + sovAuctionPool(uint64(m.MaxAllowedBid))
	}
	if m.EndDuration != 0 {
		n += 1 + sovAuctionPool(uint64(m.EndDuration))
	}
	if m.LastBlock != 0 {
		n += 1 + sovAuctionPool(uint64(m.LastBlock))
	}
	if m.CurrentBid != 0 {
		n += 1 + sovAuctionPool(uint64(m.CurrentBid))
	}
	l = len(m.CurrentWinner)
	if l > 0 {
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	return n
}

func (m *DescendingAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovAuctionPool(uint64(m.Status))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	if m.Supply != 0 {
		n += 1 + sovAuctionPool(uint64(m.Supply))
	}
	if m.MinAllowedBid != 0 {
		n += 1 + sovAuctionPool(uint64(m.MinAllowedBid))
	}
	if m.MaxAllowedBid != 0 {
		n += 1 + sovAuctionPool(uint64(m.MaxAllowedBid))
	}
	if m.StartingBid != 0 {
		n += 1 + sovAuctionPool(uint64(m.StartingBid))
	}
	if m.CurrentBid != 0 {
		n += 1 + sovAuctionPool(uint64(m.CurrentBid))
	}
	if m.BidStepSize != 0 {
		n += 1 + sovAuctionPool(uint64(m.BidStepSize))
	}
	if m.BidStepDuration != 0 {
		n += 1 + sovAuctionPool(uint64(m.BidStepDuration))
	}
	if m.NextStep != 0 {
		n += 1 + sovAuctionPool(uint64(m.NextStep))
	}
	return n
}

func (m *SealedBidAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovAuctionPool(uint64(m.Status))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	if m.Supply != 0 {
		n += 1 + sovAuctionPool(uint64(m.Supply))
	}
	if m.MinAllowedBid != 0 {
		n += 1 + sovAuctionPool(uint64(m.MinAllowedBid))
	}
	if m.MaxAllowedBid != 0 {
		n += 1 + sovAuctionPool(uint64(m.MaxAllowedBid))
	}
	if m.AuctionDuration != 0 {
		n += 1 + sovAuctionPool(uint64(m.AuctionDuration))
	}
	if m.RevealDuration != 0 {
		n += 1 + sovAuctionPool(uint64(m.RevealDuration))
	}
	if m.FirstBlock != 0 {
		n += 1 + sovAuctionPool(uint64(m.FirstBlock))
	}
	if m.LastBlock != 0 {
		n += 1 + sovAuctionPool(uint64(m.LastBlock))
	}
	if m.RevealBlock != 0 {
		n += 1 + sovAuctionPool(uint64(m.RevealBlock))
	}
	return n
}

func (m *Auction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algorithm != 0 {
		n += 1 + sovAuctionPool(uint64(m.Algorithm))
	}
	if m.XAscendingAuction != nil {
		n += m.XAscendingAuction.Size()
	}
	if m.XDescendingAuction != nil {
		n += m.XDescendingAuction.Size()
	}
	if m.XSealedBidAuction != nil {
		n += m.XSealedBidAuction.Size()
	}
	return n
}

func (m *Auction_AscendingAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AscendingAuction != nil {
		l = m.AscendingAuction.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	return n
}
func (m *Auction_DescendingAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescendingAuction != nil {
		l = m.DescendingAuction.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	return n
}
func (m *Auction_SealedBidAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SealedBidAuction != nil {
		l = m.SealedBidAuction.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	return n
}
func (m *AuctionPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAuctionPool(uint64(m.Id))
	}
	l = len(m.PoolAddress)
	if l > 0 {
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	if m.MinAllowedSupply != 0 {
		n += 1 + sovAuctionPool(uint64(m.MinAllowedSupply))
	}
	if m.MaxAllowedSupply != 0 {
		n += 1 + sovAuctionPool(uint64(m.MaxAllowedSupply))
	}
	if len(m.AllowedAlgorithms) > 0 {
		l = 0
		for _, e := range m.AllowedAlgorithms {
			l += sovAuctionPool(uint64(e))
		}
		n += 1 + sovAuctionPool(uint64(l)) + l
	}
	if m.LatestAuction != nil {
		l = m.LatestAuction.Size()
		n += 1 + l + sovAuctionPool(uint64(l))
	}
	return n
}

func sovAuctionPool(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAuctionPool(x uint64) (n int) {
	return sovAuctionPool(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AscendingAuction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuctionPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AscendingAuction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AscendingAuction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AuctionState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supply", wireType)
			}
			m.Supply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Supply |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAllowedBid", wireType)
			}
			m.MinAllowedBid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAllowedBid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAllowedBid", wireType)
			}
			m.MaxAllowedBid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAllowedBid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDuration", wireType)
			}
			m.EndDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlock", wireType)
			}
			m.LastBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBid", wireType)
			}
			m.CurrentBid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentBid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentWinner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentWinner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuctionPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescendingAuction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuctionPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescendingAuction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescendingAuction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AuctionState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supply", wireType)
			}
			m.Supply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Supply |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAllowedBid", wireType)
			}
			m.MinAllowedBid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAllowedBid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAllowedBid", wireType)
			}
			m.MaxAllowedBid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAllowedBid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingBid", wireType)
			}
			m.StartingBid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartingBid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBid", wireType)
			}
			m.CurrentBid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentBid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidStepSize", wireType)
			}
			m.BidStepSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BidStepSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidStepDuration", wireType)
			}
			m.BidStepDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BidStepDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			m.NextStep = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextStep |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuctionPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealedBidAuction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuctionPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealedBidAuction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealedBidAuction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AuctionState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supply", wireType)
			}
			m.Supply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Supply |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAllowedBid", wireType)
			}
			m.MinAllowedBid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAllowedBid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAllowedBid", wireType)
			}
			m.MaxAllowedBid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAllowedBid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionDuration", wireType)
			}
			m.AuctionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevealDuration", wireType)
			}
			m.RevealDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevealDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstBlock", wireType)
			}
			m.FirstBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlock", wireType)
			}
			m.LastBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevealBlock", wireType)
			}
			m.RevealBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevealBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuctionPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Auction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuctionPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Auction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Auction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= AuctionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AscendingAuction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AscendingAuction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.XAscendingAuction = &Auction_AscendingAuction{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescendingAuction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DescendingAuction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.XDescendingAuction = &Auction_DescendingAuction{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealedBidAuction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SealedBidAuction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.XSealedBidAuction = &Auction_SealedBidAuction{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuctionPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuctionPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAllowedSupply", wireType)
			}
			m.MinAllowedSupply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAllowedSupply |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAllowedSupply", wireType)
			}
			m.MaxAllowedSupply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAllowedSupply |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v AuctionType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuctionPool
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= AuctionType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AllowedAlgorithms = append(m.AllowedAlgorithms, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuctionPool
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAuctionPool
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAuctionPool
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.AllowedAlgorithms) == 0 {
					m.AllowedAlgorithms = make([]AuctionType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v AuctionType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuctionPool
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= AuctionType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AllowedAlgorithms = append(m.AllowedAlgorithms, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedAlgorithms", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestAuction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuctionPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LatestAuction == nil {
				m.LatestAuction = &Auction{}
			}
			if err := m.LatestAuction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuctionPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuctionPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuctionPool(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuctionPool
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuctionPool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAuctionPool
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAuctionPool
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAuctionPool
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAuctionPool        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuctionPool          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAuctionPool = fmt.Errorf("proto: unexpected end of group")
)
